# DEFLATE📝


<!-- 太空漫步 Space Walk - HOYO-MiX -->
<!-- {{< music server="netease" type="song" id="2034615687" autoplay="true" >}} -->

DEFLATE是同时使用了[LZ77](../lz77)算法和哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。它最初由Phil Katz为其PKZIP软件第二版所定义，后来被RFC 1951标准化。DEFLATE在zip、gzip和png文件中均有应用。

Matlab中有内建的gzip实现，可以直接调用，本文只是从原理上简述DEFLATE算法的流程。

## 引言

DEFLATE算法由改进的LZ77压缩算法和Huffman编码算法组成。改进的LZ77算法和Huffman编码算法保留了原算法的基本原理，提高了DEFLATE算法的压缩速度，增加了算法灵活度，使其具备良好的适应性。

在DEFLATE算法中，首先使用改进的LZ77算法对原始数据进行压缩，然后使用改进的Huffman编码对LZ77压缩数据进行二次压缩，最终压缩数据为Huffman编码后的LZ77压缩数据。

## 改进LZ77

LZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进：
- 对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。
- 对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。
- 由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。

<div style="text-align: center;">
	<table style="margin: auto;">
	<caption>改进的LZ77算法压缩数据存储格式</caption>
		<tr>
			<th align="center" rowspan="2">原始数据</th><th colspan="3" align="center">压缩后数据</th>
		</tr>
		<tr>
			<th>标识(1-bit)</th><th>数据(8-bit)</th><th>偏移(15-bit)</th>
		</tr>
		<tr>
			<td>匹配长度小于3</td><td>0</td><td>原始数据</td><td>无</td>
		</tr>
		<tr>
			<td>匹配长度大于3</td><td>1</td><td>匹配长度</td><td>偏移距离</td>
		</tr>
	</table>
</div>

## 改进Huffman

经过Huffman编码压缩后的压缩数据由码表和编码数据两部分组成，在DEFLATE算法中使用的Huffman编码算法，根据码表的生成方式不同，分为静态Huffman编码和动态Huffman编码，其中静态Huffman编码使用预先定义码表并始终固定，无需在压缩数据中存储，动态Huffman编码需要根据待处理数据情况，生成动态码表，并在压缩数据中存储，DEFLATE算法中主要对动态Huffman编码算法进行了以下改进：

- 固定Huffman码表生成规则，从Huffman编码的构造可知，同样的数据由于二叉树的生成方式或顺序不同，可以得到不同的Huffman码表，通过固定二叉树生成方式及顺序，使同样的数据得到相同的Huffman码表。
- 使用码长记录码表，进一步压缩码表占用的存储空间，这样使用1字节就可以表示码长为1到256的任一码字。
- 对需要存储的Huffman码表进行了二次编码压缩，在DEFLATE算法中最终使用3张Huffman编码表，实现了其Huffman编码表的存储。

改进后的Huffman编码算法，在兼顾运算速度的情况下，有效减少了压缩数据的存储空间。

## DEFLATE处理流程

DEFLATE将所有待压缩的数据都看成二进制数据流，最基本的处理元素为字节，其中Huffman编码算法采用动态或静态编码由DEFLATE算法根据压缩比进行自动选择。其中采用动态Huffman编码的DEFLATE算法具体处理流程如图1所示。首先将原始数据进行LZ77压缩处理，对应表中的数据构成，得到“标识+数据”和“偏移”两部分数据；然后使用Huffman编码算法对两部分数据分别进行压缩，得到“码表1”和“码表2”，以及使用两张码表编码压缩的“压缩数据1”和“压缩数据2”；最后继续使用Huffman编码对“码表1”和“码表2”进行压缩，得到“码表3”和“压缩数据3”。

{{< image src="deflate.svg" caption="DEFLATE流程图" width="800">}}

经过上述处理，原始数据经过压缩后，采用静态Huffman编码的DEFLATE算法需要存储的数据为“压缩数据1”和“压缩数据2”；采用动态Huffman编码的DEFLATE算法需要存储的数据为“压缩数据1”、“压缩数据2”、“压缩数据3”和“码表3”，解压缩为压缩过程的逆运算。
