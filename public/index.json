[{"categories":["Lab"],"content":"Word 公式编号与对齐","date":"2023-07-06","objectID":"/word-equation/","series":null,"tags":["Research","Office","Math"],"title":"Word 公式编号与对齐🧉","uri":"/word-equation/"},{"categories":["Lab"],"content":"多行公式（包括矩阵）先在 Markdown 中写好，之后复制进 Word 中删除空格后，在最后一个字符处回车。 ","date":"2023-07-06","objectID":"/word-equation/:0:0","series":null,"tags":["Research","Office","Math"],"title":"Word 公式编号与对齐🧉","uri":"/word-equation/#"},{"categories":["Lab"],"content":"\r参考 Word多行公式的换行、对齐与编号 Word 2016自带公式编辑器如何做到等号对齐？ ","date":"2023-07-06","objectID":"/word-equation/:1:0","series":null,"tags":["Research","Office","Math"],"title":"Word 公式编号与对齐🧉","uri":"/word-equation/#参考"},{"categories":["Lab"],"content":"C/A 码生成器是由两个不同的 LSFR 组合而成","date":"2023-07-04","objectID":"/lfsr/","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/"},{"categories":["Lab"],"content":"\r线性反馈移位寄存器\rLinear Feedback Shift Register, LFSR, 作为线性驱动部分来生成伪随机码，是数学意义上的最优解，自相关函数除主峰外具有最大平坦。\r","date":"2023-07-04","objectID":"/lfsr/:0:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#"},{"categories":["Lab"],"content":"\rLFSR引入若干个寄存器排列成一行，每个寄存器存储着一个二进制数。移位寄存器每次将最右端(末端)的数字输出，然后整体向右移动移位。同时具有一个反馈函数，以寄存器中已有的某些序列作为反馈函数的输入，将反馈函数的输出填充到移位寄存器的最左端，这样的，拥有反馈函数的移位寄存器称为反馈移位寄存器。 ","date":"2023-07-04","objectID":"/lfsr/:1:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#lfsr引入"},{"categories":["Lab"],"content":"\r反馈函数 LFSR的反馈函数就是简单地对移位寄存器中的某些位进行异或，并将异或的结果填充到LFSR的最左端。对于LFSR中每一位的数据，可以参与异或，也可以不参与异或。其中，我们把参与异或的位称为抽头。 $$ b_{n+1} = c_1b_1 \\oplus c_2b_2 \\oplus \\ldots \\oplus c_nb_n \\tag{1} $$ ","date":"2023-07-04","objectID":"/lfsr/:2:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#反馈函数"},{"categories":["Lab"],"content":"\r级数LFSR 的级数就是其中寄存器的个数，一个 $n$ 级的 LFSR 最多可以存储 $2^n-1$ 种状态，因为全零的状态反馈值始终是全零。至于为什么最多能够遍历 $2^n-1$ 种状态，将在之后介绍。一个 $n$ 级的 LFSR 的最大周期就是 $2^n-1$ ，我们将周期为 $2^n-1$ 的 LFSR 所生成的序列称为m 序列。 ","date":"2023-07-04","objectID":"/lfsr/:3:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#级数"},{"categories":["Lab"],"content":"\r特征多项式由 (1) 中的式子可以得到一个 LFSR 的递推关系式，则这个递推关系可以对应这一个特征多项式 $$ f(x) = c_nx^n + c_{n-1} + \\ldots + c_2x^2 + c_1x + 1\\tag{2} $$ 这里的 $c_i$ 与之前的定义相同，表示是否抽头。最终得到的特征多项式只保留抽头位次项，并加一。可以理解为一个 LFSR 的不同特征多项式对应着不同的反馈函数。 ","date":"2023-07-04","objectID":"/lfsr/:4:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#特征多项式"},{"categories":["Lab"],"content":"\r本原多项式首先给出一个结论 信息\r$n$ 级 LFSR 能够产生 $m$ 序列的充要条件为其特征多项式为本原多项式\r接下来以此引入不可约多项式和本原多项式。 不可约多项式\rIrreducible Polynomial. 一个多项式在指定域上不能分解，则称为不可约多项式，即不能等于次数更小的多项式的乘积。\rLFSR 中采用的有限域为 $GF(2^n)$ ，指多项式的系数要小于 2，即为 0 或 1，多项式的最高次数不能够大于或等于 n。如 $GF(2^3)$ 中的多项式为 $0, 1, x, x+1$ 。 本原多项式\rPrimitive Polynomial. 本原多项式本身就是一种不可约多项式，但是需要满足以下三个条件：对于 $n$ 次的本原多项式 $F(x)$。\r$F(x)$ 是不可约的，不能再分解多项式 $F(x)$ 可整除 $x^p+1$ ，其中 $p = 2^n-1$ $F(x)$ 不能整除 $x^q+1$ ，其中 $q\u003cp$ 由本原多项式可以得到生成 $m$ 序列的反馈函数，如 $n=10$ 时本原多项式为 $$\rF(x) = x^{10} + x^3 + 1\\tag{3}\r$$\r则反馈函数就表示为 [0,0,1,0,0,0,0,0,0,1] ，意味着第 3 位寄存器和第 10 位寄存器中的值做异或得到的输出赋值给最左端的寄存器，实现移位反馈。 技巧\rMATLAB 中 primpoly 函数可以查看任意次数的本原多项式\r","date":"2023-07-04","objectID":"/lfsr/:5:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#本原多项式"},{"categories":["Lab"],"content":"\r$m$ 序列的性质$m$ 序列实际上就是我们称呼的伪随机码或者扩频码。 ","date":"2023-07-04","objectID":"/lfsr/:6:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#m-序列的性质"},{"categories":["Lab"],"content":"\r均衡性在 $m$ 序列的一个周期中，0 和 1 的数目基本相等，1 的个数会比 0 多一个。 ","date":"2023-07-04","objectID":"/lfsr/:6:1","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#均衡性"},{"categories":["Lab"],"content":"\r移位相加性一个 $m$ 序列 $m_1$ 与其经过任意延迟移位产生的另一序列 $m_2$ 模 2 相加(异或)，得到的仍是 $m_1$ 的某次延迟移位序列 $m_3$。 ","date":"2023-07-04","objectID":"/lfsr/:6:2","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#移位相加性"},{"categories":["Lab"],"content":"\r自相关性由于 1 的个数始终比 0 多一个，因此在做自相关的过程中，始终会得到一个 -1 的值，这与完全的随机信号有着很大的区别。 $$\rR(\\tau) = \\left\\{\r\\begin{align*}\r\u00261, \u0026\\tau = 0\\\\\r\u0026-\\frac{1}{N}, \u0026\\mathrm{else}\r\\end{align*}\\right.\\tag{4}\r$$\r","date":"2023-07-04","objectID":"/lfsr/:6:3","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#自相关性"},{"categories":["Lab"],"content":"\r游程分布$m$ 序列中取值相同的相继元素合称为一个“游程”，游程中元素的个数称为游程长度。n 位 LFSR 生成的 $m$ 序列中，总共由 $2^{n-1}$ 个游程，其中长度为 1 的游程占总游程数的 1/2，长度为 2 游程占总游程数的 1/4，长度为 k 的游程占总游程数的 $2^{-k}$ ，且长度为 k 的游程中，连 0 和连 1 的游程数各占一半。游程分布具有很好的均衡性。 如序列 1000010010110011111000110111010 中，游程总数为 $2^{5-1}=16$ ，各个长度的游程分布如下： 长度为 1 的游程数目为 8，其中 4 个 1 游程和 4 个 0 游程 长度为 2 的游程数目为 4，其中 2 个 11 游程和 2 个 00 游程 长度为 3 的游程数目为 2，其中 1 个 111 游程和 1 个 000 游程 长度为 4 的连 0 游程数目为 1 长度为 5 的连 1 游程数目为 1 ","date":"2023-07-04","objectID":"/lfsr/:6:4","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#游程分布"},{"categories":["Lab"],"content":"\r附录由于时间原因，之前有关本原多项式的生成和证明有所省略，未来有时间可以在其他文献中进行查阅 Generation of primitive binary polynomial LFSR AND PRIMITIVE POLYNOMIAL ","date":"2023-07-04","objectID":"/lfsr/:7:0","series":null,"tags":["GNSS","Signal","LSFR","Research"],"title":"线性反馈移位寄存器🛅","uri":"/lfsr/#附录"},{"categories":["Lab"],"content":"DEFLATE","date":"2023-06-27","objectID":"/deflate/","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/"},{"categories":["Lab"],"content":"\rDEFLATE是同时使用了LZ77算法和哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。它最初由Phil Katz为其PKZIP软件第二版所定义，后来被RFC 1951标准化。DEFLATE在zip、gzip和png文件中均有应用。 Matlab中有内建的gzip实现，可以直接调用，本文只是从原理上简述DEFLATE算法的流程。 ","date":"2023-06-27","objectID":"/deflate/:0:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#"},{"categories":["Lab"],"content":"\r引言DEFLATE算法由改进的LZ77压缩算法和Huffman编码算法组成。改进的LZ77算法和Huffman编码算法保留了原算法的基本原理，提高了DEFLATE算法的压缩速度，增加了算法灵活度，使其具备良好的适应性。 在DEFLATE算法中，首先使用改进的LZ77算法对原始数据进行压缩，然后使用改进的Huffman编码对LZ77压缩数据进行二次压缩，最终压缩数据为Huffman编码后的LZ77压缩数据。 ","date":"2023-06-27","objectID":"/deflate/:1:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#引言"},{"categories":["Lab"],"content":"\r改进LZ77LZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进： 对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。 对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。 由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。 改进的LZ77算法压缩数据存储格式\r原始数据压缩后数据\r标识(1-bit)数据(8-bit)偏移(15-bit)\r匹配长度小于30原始数据无\r匹配长度大于31匹配长度偏移距离\r","date":"2023-06-27","objectID":"/deflate/:2:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#改进lz77"},{"categories":["Lab"],"content":"\r改进Huffman经过Huffman编码压缩后的压缩数据由码表和编码数据两部分组成，在DEFLATE算法中使用的Huffman编码算法，根据码表的生成方式不同，分为静态Huffman编码和动态Huffman编码，其中静态Huffman编码使用预先定义码表并始终固定，无需在压缩数据中存储，动态Huffman编码需要根据待处理数据情况，生成动态码表，并在压缩数据中存储，DEFLATE算法中主要对动态Huffman编码算法进行了以下改进： 固定Huffman码表生成规则，从Huffman编码的构造可知，同样的数据由于二叉树的生成方式或顺序不同，可以得到不同的Huffman码表，通过固定二叉树生成方式及顺序，使同样的数据得到相同的Huffman码表。 使用码长记录码表，进一步压缩码表占用的存储空间，这样使用1字节就可以表示码长为1到256的任一码字。 对需要存储的Huffman码表进行了二次编码压缩，在DEFLATE算法中最终使用3张Huffman编码表，实现了其Huffman编码表的存储。 改进后的Huffman编码算法，在兼顾运算速度的情况下，有效减少了压缩数据的存储空间。 ","date":"2023-06-27","objectID":"/deflate/:3:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#改进huffman"},{"categories":["Lab"],"content":"\rDEFLATE处理流程DEFLATE将所有待压缩的数据都看成二进制数据流，最基本的处理元素为字节，其中Huffman编码算法采用动态或静态编码由DEFLATE算法根据压缩比进行自动选择。其中采用动态Huffman编码的DEFLATE算法具体处理流程如图1所示。首先将原始数据进行LZ77压缩处理，对应表中的数据构成，得到“标识+数据”和“偏移”两部分数据；然后使用Huffman编码算法对两部分数据分别进行压缩，得到“码表1”和“码表2”，以及使用两张码表编码压缩的“压缩数据1”和“压缩数据2”；最后继续使用Huffman编码对“码表1”和“码表2”进行压缩，得到“码表3”和“压缩数据3”。 DEFLATE流程图\r经过上述处理，原始数据经过压缩后，采用静态Huffman编码的DEFLATE算法需要存储的数据为“压缩数据1”和“压缩数据2”；采用动态Huffman编码的DEFLATE算法需要存储的数据为“压缩数据1”、“压缩数据2”、“压缩数据3”和“码表3”，解压缩为压缩过程的逆运算。 ","date":"2023-06-27","objectID":"/deflate/:4:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#deflate处理流程"},{"categories":["Lab"],"content":"LZ77","date":"2023-06-27","objectID":"/lz77/","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/"},{"categories":["Lab"],"content":"\r","date":"2023-06-27","objectID":"/lz77/:0:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#"},{"categories":["Lab"],"content":"\r引言LZ77是一种采用字典进行数据压缩的经典压缩算法，由两位以色列工程师Jacob Ziv和Abraham Lempel在1977年发表的论文“A Universal Algorithm for Sequential Data Compression”中提出。 传统基于统计的压缩编码，如Huffman编码，需要得到先验信息——信源的字符频率，然后进行压缩。但是在大多数情况下，这种先验信息是很难预先获得的。因此，设计一种更为通用的数据压缩编码显得尤为重要，LZ77数据压缩算法应运而生，其核心思想是，利用数据的重复结构信息来进行数据压缩。即如果字符串中的信息在之前出现过，则只需要指出其之前出现过的位置，便可以用相对索引来表示这些词。 ","date":"2023-06-27","objectID":"/lz77/:1:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#引言"},{"categories":["Lab"],"content":"\r原理这里仅讨论LZ77算法的压缩和解压缩过程，关于LZ77算法的唯一可译、无损压缩的性质，其数学证明参看原论文。 ","date":"2023-06-27","objectID":"/lz77/:2:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#原理"},{"categories":["Lab"],"content":"\r滑动窗口首先，定义字符串$S$的长度为$N$，字符串$S$的子串$S_{ij},1\\leq i,j \\leq N$。对于前缀子串$S_{1,j}$，记$L_i^j$为首字符$S_i$的子串与首字符$S_{j+1}$的子串的最大匹配长度，即： $$ L_i^j=\\max{l|S_{i,i+l-1}=S_{j+1,j+l}},\\quad l\\leq N-j $$ 我们称字符串$S_{j+1,j+l}$匹配了字符串$S_{i,i+l-1}$，且匹配长度为$l$。如图所示，共有两种情况 定义$p^j$为所有情况下的最长匹配的起始位置$i$值，即 $$ p^i = \\mathop{\\arg\\max}\\limits_i{L_i^j}, \\quad 1\\leq i \\leq j $$ 如对于字符串$S=00101011,j=3$则有 $L_1^j=1\\rightarrow S_{j+1,j+1}=S_{1,1},S_{j+1,j+2}\\neq S_{1,2}$ $L_2^j=4\\rightarrow S_{j+1,j+1}=S_{2,2},S_{j+1,j+2}=S_{2,3},S_{j+1,j+3}=S_{2,4},S_{j+1,j+4}=S_{2,5},S_{j+1,j+5}\\neq S_{2,6}$ $L_3^j=0\\rightarrow S_{j+1,j+1}\\neq S_{3,3}$ 因此，$p^j=2$且最长匹配的长度$l^j=4$。由此可知，子串$S_{j+1,j+p}$是可以由$S_{1,j}$生成的，因而称之为$S_{1,j}$的再生扩展（Reproducible Extension）。LZ77算法的核心思想便来源于此——用历史中出现过的字符串做字典，编码未来出现的字符，以达到数据压缩的目的。在具体实现中，用滑动窗口（Sliding Window）字典存储历史字符，Lookahead-Buffer存储待压缩的字符，Cursor作为两者之间的分隔，如图所示 并且字典与Lookahead Buffer的长度是固定的。 ","date":"2023-06-27","objectID":"/lz77/:2:1","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#滑动窗口"},{"categories":["Lab"],"content":"\r压缩用$(p,l,c)$表示Lookahead Buffer中字符串的最长匹配结果，其中 $p$表示最长匹配时，字典中字符开始时的位置（相对于Cursor位置） $l$为最长匹配字符串的长度 $c$指Lookahead Buffer最长匹配结束时的下一字符 压缩的过程，就是重复输出$(p,l,c)$，并将Cursor移动至$l+1$，算法如下 Repeat: Output (p,l,c), Cursor --\u003e l+1 Until to end of string 压缩示例如图所示 ","date":"2023-06-27","objectID":"/lz77/:2:2","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#压缩"},{"categories":["Lab"],"content":"\r解压缩为了能保证正确解码，解压缩时的滑动窗口与压缩时要相同。在解压缩时，遇到$(p,l,c)$大致分为三类情况： $p==0$且$l==0$，即初始情况，这时直接解码$c$ $p\\geq l$，解码为字典dict[p:p+l+1] $p\u003cl$，即出现循环编码，则需要从左至右循环拼接，伪代码如下 for (i = p, k = 0; k \u003c length; i++, k++) out[cursor+k] = dict[i%cursor] 比如，dict=abcd，编码为(2,9,e)，则解压缩为output=abcdcdcdcdcdce。 ","date":"2023-06-27","objectID":"/lz77/:2:3","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#解压缩"},{"categories":["Lab"],"content":"\r实现用matlab实现一个简单的LZ77压缩算法，由于我的目的主要时压缩数组，因此用数组代替字符串进行压缩设计和测试，具体实现如下 classdef LZ77 % A simple implementation of LZ77 compression algorithm properties (SetAccess = private) window_size % dictionary buffer_size % lookahead buffer end methods function self = LZ77(d, h) if nargin == 2 self.window_size = d; self.buffer_size = h; elseif nargin == 1 self.window_size = d; self.buffer_size = 4; elseif nargin == 0 self.window_size = 6; self.buffer_size = 4; end end function [p, l, c] = longest_match(self, data, cursor) % Find the longest match between dictionary and % lookahead-buffer. % % arguments: (input) % data - data used to find longest match % cursor - position of data that seperate dictionary and % lookahead-buffer, from 0 to data length, value of % cursor should be equal to its left item's index % arguments: (output) % p - start point of longest match based on cursor % l - length of longest match % c - next character of longest match end_buffer = min(cursor + self.buffer_size, length(data)-1); p = -1; l = -1; c = ''; for i = cursor+1:end_buffer start_index = max(1, cursor - self.window_size + 1); sub_string = data(cursor+1:i); subs_len = length(sub_string); for j = start_index:cursor repetition = floor(subs_len / (cursor - j + 1)); last = rem(subs_len, (cursor - j + 1)); matched_string = [repmat(data(j:cursor), ... [1 repetition]), data(j:j+last-1)]; % if match, update p, l, c if isequal(matched_string, sub_string) \u0026\u0026 subs_len \u003e l p = cursor - j + 1; l = subs_len; c = data(i+1); end end end % if not match, return next character of cursor if p == -1 \u0026\u0026 l == -1 p = 0; l = 0; c = data(cursor + 1); end end function cm = compress(self, message) % Compress message % % arguments: (input) % message - data ready to compress % arguments: (output) % cm - compressed message i = 0; while i \u003c length(message) [p, l, c] = self.longest_match(message, i); if exist('cm', 'var') cm = [cm;[p,l,c]]; else cm = [p,l,c]; end i = i + l + 1; end end function dm = decompress(self, cm) % Decompress the compressed message % % arguments: (input) % cm - compressed message % arguments: (output) % dm - decompressed message cursor = 0; [n, ~] = size(cm); dm = []; for i = 1:n p = cm(i,1); l = cm(i,2); c = cm(i,3); if p == 0 \u0026\u0026 l == 0 dm = [dm, c]; elseif p \u003e= l dm = [dm, dm(cursor - p + 1: cursor - p + l), c]; elseif p \u003c l repetition = floor(l / p); last = rem(l, p); dm = [dm, repmat(dm(cursor-p+1:cursor), ... [1 repetition]), dm(cursor-p+1:cursor-p+last), c]; end cursor = cursor + l + 1; end end end end 整体的编码解码逻辑清楚，解码过程中的循环匹配也较为简单。在寻找最大匹配子串中，前置子串采用了和循环匹配一样的生成方式，其实其他方式也是一样的，这里的生成方式不本质。 值得注意的是，在寻找最大匹配子串中时，Lookahead-Buffer是不能取到数据的最后一位的，即需要length(data)-1。这是因为如果Cursor后的数据全部匹配的话，这样匹配后的下一个字符索引会超出边界，而保证Lookahead-Buffer最多只到倒数第二个字符的话，能够保证就算在全部匹配之后还能够留有一个字符附在$(p,l,c)$中的$c$ 处，从而有效避免了数组越界的情况，同时压缩效率也没有下降。 end_buffer = min(cursor + self.buffer_size, length(data)-1); ","date":"2023-06-27","objectID":"/lz77/:3:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#实现"},{"categories":["Lab"],"content":"\r性能在Dictionary和Lookahead-Buffer长度较小的时候，LZ77的压缩速度很快，但是压缩率很低，对于重复数据出现少的情况，甚至可能出现压缩后的数据比压缩之前还要大的情况。对于Dictionary和Lookahead-Buffer长度较小的情况，压缩效果较好，但是压缩速度很慢，且长度越大，压缩效果越好，压缩速度越慢。 对于Dictionary和Lookahead-Buffer长度均为80时，测试小天线的蓝盒子采集数据，压缩比约为1.29:1，压缩率为22%；扩大窗长度到200时，同样数据，压缩比约为1.49:1，压缩率为33%。 对于解压缩，由于和Dictionary和Lookahead-Buffer长度无关，因此解压缩速度均很快。 直接使用zip对2.29G的原始采集数据进行压缩，压缩比在3.35:1左右，由于也是基于LZ77算法的变种，性能相较直接的压缩有提升，但是整体数据量大也会导致压缩率的提升。 ","date":"2023-06-27","objectID":"/lz77/:4:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#性能"},{"categories":["Lab"],"content":"\r参考 Ziv, Jacob, and Abraham Lempel. “A universal algorithm for sequential data compression.” IEEE Transactions on information theory 23.3 (1977): 337-343. LZ77算法原理及实现 ","date":"2023-06-27","objectID":"/lz77/:5:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#参考"},{"categories":["Life"],"content":"alist yyds","date":"2023-06-26","objectID":"/alist/","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/"},{"categories":["Life"],"content":"\rAlist是一个使用 Gin 和 Solidjs 开发的支持多种存储的文件列表程序，其具有优秀的性能和美观的用户界面，能够很好地对各种网盘以及本地存储文件进行管理和多平台访问（主要是视频、图像和音频）。 欢迎访问我的 Alist 站点：sereinme’s alist。 ","date":"2023-06-26","objectID":"/alist/:0:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#"},{"categories":["Life"],"content":"\r安装由于本机用 Windows 系统作为服务主机，直接利用 scoop 进行安装，参考其官网中的介绍，在 PowerShell 中输入如下命令： scoop bucket add main scoop install main/alist 待安装完成后输入 alist version 来查看是否正确安装。 ","date":"2023-06-26","objectID":"/alist/:1:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#安装"},{"categories":["Life"],"content":"\r配置Alist 具体配置在其官网有着极其详细的描述，在此只进行简单的配置和操作介绍，以下的步骤都是在安装了 Alist 的服务器主机中进行。 ","date":"2023-06-26","objectID":"/alist/:2:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#配置"},{"categories":["Life"],"content":"\r用户名和密码刚完成 Alist 安装后，在终端输入 alist server 将开启 alist 服务，默认的服务是在本机的 5244 端口，初始用户名为 admin ，同时在终端输出中会提示用户的初始密码，利用此用户名和密码可以在浏览器的 localhost:5244 中登录 alist ，如果成功登录，则说明 alist 初始化成功。 之后在下方点击管理可以进入到 Alist 的配置，在其中的个人资料中修改用户名和登录密码，点击保存，就完成了用户名和密码的设置。 ","date":"2023-06-26","objectID":"/alist/:2:1","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#用户名和密码"},{"categories":["Life"],"content":"\r云盘和存储添加各种存储的具体方式见 Alist 官网，其就是在 Alist 管理中选取存储，然后添加存储类型，之后按照官网中的描述进行配置，完成后就会在主页出现相应添加的存储部分。 ","date":"2023-06-26","objectID":"/alist/:2:2","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#云盘和存储"},{"categories":["Life"],"content":"\r开机自启在 Windows 系统中实现开机自启有多种方法，笔者采用的是 Task Schedular (任务计划程序) 进行实现。 任务计划程序中创建任务的方式见参考资料，需要注意的是，其启动程序的脚本应是 alist start 这样会打开之前配置完成的 Alist 服务，而如果用 alist server 的话，会打开一个全新未经过配置的 Alist 服务。 ","date":"2023-06-26","objectID":"/alist/:2:3","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#开机自启"},{"categories":["Life"],"content":"\r使用在其他设备上使用 Alist 时，需要知道服务器主机的 IP 地址，可以通过 ipconfig 命令进行查看。 ","date":"2023-06-26","objectID":"/alist/:3:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#使用"},{"categories":["Life"],"content":"\r浏览器对于没有经过 https 和端口配置等的 Alist 服务，直接在浏览器中输入 http://\u003cdomain\u003e:5244 就可以进入服务器主机的 Alist 界面中，在进行了登录之后能够对其中的文件进行查看和修改操作。 ","date":"2023-06-26","objectID":"/alist/:3:1","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#浏览器"},{"categories":["Life"],"content":"\rWebDavAlist 支持利用 WebDav 协议进行文件共享，其 WebDav 配置如下 Name Value Url http[s]://domain:port/dav/ Host domain 路径 dav 协议 http/https 端口 与网页端一致 WebDAV用户名 与网页端用户名一致 WebDAV密码 与网页端密码一致 ","date":"2023-06-26","objectID":"/alist/:3:2","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#webdav"},{"categories":["Life"],"content":"\r参考资料 Alist 官网 Alist · Github 用Windows自带的Task Scheduler部署一个定时任务启动一个程序 ","date":"2023-06-26","objectID":"/alist/:4:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#参考资料"},{"categories":["Life"],"content":"装电脑喽","date":"2023-06-25","objectID":"/computer/","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/"},{"categories":["Life"],"content":"\r我进入大学买的第一台笔记本是 HP 的 EliteBook，配置是 ","date":"2023-06-25","objectID":"/computer/:0:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#"},{"categories":["Life"],"content":"\r配置考虑到组装电脑的用途以及性价比，选取的装机配置如下表所示。 类型 价格 型号 尺寸 其他 CPU 2769 i7-13790F x GPU 2799 ASUS TUF RTX3060 30cm x 主板 1499 ROG STRIX B760-G MATX x 内存 939 16x2 DDR5 金士顿 x SSD 599 三星 980Pro 1T x 电源 599 海韵 G12 650W x 机箱 539 迎广 A3 显卡\u003c34cm x 散热 190 利民 PA120 x 总计 9933 ","date":"2023-06-25","objectID":"/computer/:1:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#配置"},{"categories":["Life"],"content":"\r装机\r","date":"2023-06-25","objectID":"/computer/:2:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#装机"},{"categories":["Life"],"content":"\r总结","date":"2023-06-25","objectID":"/computer/:3:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#总结"},{"categories":["Life"],"content":"\r致谢感谢胡昌宇同学在我装机时对我的帮助，特请奶茶一杯😊。 ","date":"2023-06-25","objectID":"/computer/:4:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#致谢"},{"categories":["Life"],"content":"毕业很累很热但是也很快乐！🎈","date":"2023-06-24","objectID":"/graduate/","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/"},{"categories":["Life"],"content":"\r毕业很累很热但是也很快乐！🎈 ","date":"2023-06-24","objectID":"/graduate/:0:0","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/#"},{"categories":["Life"],"content":"\r照片\r","date":"2023-06-24","objectID":"/graduate/:1:0","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/#照片"},{"categories":["Life"],"content":"\r视频\r","date":"2023-06-24","objectID":"/graduate/:2:0","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/#视频"},{"categories":null,"content":"about","date":"2023-06-24","objectID":"/about/","series":null,"tags":null,"title":"关于 Sereinme 🛹","uri":"/about/"},{"categories":null,"content":"\r","date":"2023-06-24","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 Sereinme 🛹","uri":"/about/#"},{"categories":null,"content":"\rSereinme\r🏫 @THU 在校生 🔬 电子工程专业 ⚡ Matlab / Python / Go / Verilog / C# 🎸 摇滚 / 金属 / Fusion 👟 篮球 / 羽毛球 / 乒乓球 🕹️ 原神 / 只狼 / 杀戮尖塔 ","date":"2023-06-24","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 Sereinme 🛹","uri":"/about/#sereinme"}]