[{"categories":["Lab"],"content":"DEFLATE","date":"2023-06-27","objectID":"/deflate/","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/"},{"categories":["Lab"],"content":"DEFLATE是同时使用了LZ77算法和哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。它最初由Phil Katz为其PKZIP软件第二版所定义，后来被RFC 1951标准化。DEFLATE在zip、gzip和png文件中均有应用。 Matlab中有内建的gzip实现，可以直接调用，本文只是从原理上简述DEFLATE算法的流程。 ","date":"2023-06-27","objectID":"/deflate/:0:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#"},{"categories":["Lab"],"content":"\r引言DEFLATE算法由改进的LZ77压缩算法和Huffman编码算法组成。改进的LZ77算法和Huffman编码算法保留了原算法的基本原理，提高了DEFLATE算法的压缩速度，增加了算法灵活度，使其具备良好的适应性。 在DEFLATE算法中，首先使用改进的LZ77算法对原始数据进行压缩，然后使用改进的Huffman编码对LZ77压缩数据进行二次压缩，最终压缩数据为Huffman编码后的LZ77压缩数据。 ","date":"2023-06-27","objectID":"/deflate/:1:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#引言"},{"categories":["Lab"],"content":"\r改进LZ77LZ77压缩算法将所有数据都处理成为一个三元组串，每个三元组至少需要3个字节表示，如果在动态字典中未找到匹配字符串，会将1个字节输出为3个字节，这就导致了字节浪费。因此在DEFLATE算法中对其使用的LZ77算法进行了以下改进： 对匹配字符串长度小于3的字符串不压缩。因为长度小于3的字符串，使用三元组表示，对原始数据不能起到压缩的作用。 对字符串的匹配长度进行了限制，范围为（-128~127），用8bit表示，滑动窗口大小为32KB，用15bit表示，将压缩数据构造为标识+数据的形式，具体如表3所示。该存储方式，降低了压缩数据的存储空间。 由于只查找匹配长度大于3的字符串，为提高算法速度，在查找匹配字符串时，使用了哈希链结构搜索算法，其中哈希算法将3字节压缩到2字节，虽然哈希链结构存在搜索到错误结果的可能，但还是大幅提高了搜索速度。 改进的LZ77算法压缩数据存储格式\r原始数据压缩后数据\r标识(1-bit)数据(8-bit)偏移(15-bit)\r匹配长度小于30原始数据无\r匹配长度大于31匹配长度偏移距离\r","date":"2023-06-27","objectID":"/deflate/:2:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#改进lz77"},{"categories":["Lab"],"content":"\r改进Huffman经过Huffman编码压缩后的压缩数据由码表和编码数据两部分组成，在DEFLATE算法中使用的Huffman编码算法，根据码表的生成方式不同，分为静态Huffman编码和动态Huffman编码，其中静态Huffman编码使用预先定义码表并始终固定，无需在压缩数据中存储，动态Huffman编码需要根据待处理数据情况，生成动态码表，并在压缩数据中存储，DEFLATE算法中主要对动态Huffman编码算法进行了以下改进： 固定Huffman码表生成规则，从Huffman编码的构造可知，同样的数据由于二叉树的生成方式或顺序不同，可以得到不同的Huffman码表，通过固定二叉树生成方式及顺序，使同样的数据得到相同的Huffman码表。 使用码长记录码表，进一步压缩码表占用的存储空间，这样使用1字节就可以表示码长为1到256的任一码字。 对需要存储的Huffman码表进行了二次编码压缩，在DEFLATE算法中最终使用3张Huffman编码表，实现了其Huffman编码表的存储。 改进后的Huffman编码算法，在兼顾运算速度的情况下，有效减少了压缩数据的存储空间。 ","date":"2023-06-27","objectID":"/deflate/:3:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#改进huffman"},{"categories":["Lab"],"content":"\rDEFLATE处理流程DEFLATE将所有待压缩的数据都看成二进制数据流，最基本的处理元素为字节，其中Huffman编码算法采用动态或静态编码由DEFLATE算法根据压缩比进行自动选择。其中采用动态Huffman编码的DEFLATE算法具体处理流程如图1所示。首先将原始数据进行LZ77压缩处理，对应表中的数据构成，得到“标识+数据”和“偏移”两部分数据；然后使用Huffman编码算法对两部分数据分别进行压缩，得到“码表1”和“码表2”，以及使用两张码表编码压缩的“压缩数据1”和“压缩数据2”；最后继续使用Huffman编码对“码表1”和“码表2”进行压缩，得到“码表3”和“压缩数据3”。 DEFLATE流程图\r经过上述处理，原始数据经过压缩后，采用静态Huffman编码的DEFLATE算法需要存储的数据为“压缩数据1”和“压缩数据2”；采用动态Huffman编码的DEFLATE算法需要存储的数据为“压缩数据1”、“压缩数据2”、“压缩数据3”和“码表3”，解压缩为压缩过程的逆运算。 ","date":"2023-06-27","objectID":"/deflate/:4:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"DEFLATE📝","uri":"/deflate/#deflate处理流程"},{"categories":["Lab"],"content":"LZ77","date":"2023-06-27","objectID":"/lz77/","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/"},{"categories":["Lab"],"content":"\r引言LZ77是一种采用字典进行数据压缩的经典压缩算法，由两位以色列工程师Jacob Ziv和Abraham Lempel在1977年发表的论文“A Universal Algorithm for Sequential Data Compression”中提出。 传统基于统计的压缩编码，如Huffman编码，需要得到先验信息——信源的字符频率，然后进行压缩。但是在大多数情况下，这种先验信息是很难预先获得的。因此，设计一种更为通用的数据压缩编码显得尤为重要，LZ77数据压缩算法应运而生，其核心思想是，利用数据的重复结构信息来进行数据压缩。即如果字符串中的信息在之前出现过，则只需要指出其之前出现过的位置，便可以用相对索引来表示这些词。 ","date":"2023-06-27","objectID":"/lz77/:1:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#引言"},{"categories":["Lab"],"content":"\r原理这里仅讨论LZ77算法的压缩和解压缩过程，关于LZ77算法的唯一可译、无损压缩的性质，其数学证明参看原论文。 ","date":"2023-06-27","objectID":"/lz77/:2:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#原理"},{"categories":["Lab"],"content":"\r滑动窗口首先，定义字符串$S$的长度为$N$，字符串$S$的子串$S_{ij},1\\leq i,j \\leq N$。对于前缀子串$S_{1,j}$，记$L_i^j$为首字符$S_i$的子串与首字符$S_{j+1}$的子串的最大匹配长度，即： $$ L_i^j=\\max{l|S_{i,i+l-1}=S_{j+1,j+l}},\\quad l\\leq N-j $$ 我们称字符串$S_{j+1,j+l}$匹配了字符串$S_{i,i+l-1}$，且匹配长度为$l$。如图所示，共有两种情况 定义$p^j$为所有情况下的最长匹配的起始位置$i$值，即 $$ p^i = \\mathop{\\arg\\max}\\limits_i{L_i^j}, \\quad 1\\leq i \\leq j $$ 如对于字符串$S=00101011,j=3$则有 $L_1^j=1\\rightarrow S_{j+1,j+1}=S_{1,1},S_{j+1,j+2}\\neq S_{1,2}$ $L_2^j=4\\rightarrow S_{j+1,j+1}=S_{2,2},S_{j+1,j+2}=S_{2,3},S_{j+1,j+3}=S_{2,4},S_{j+1,j+4}=S_{2,5},S_{j+1,j+5}\\neq S_{2,6}$ $L_3^j=0\\rightarrow S_{j+1,j+1}\\neq S_{3,3}$ 因此，$p^j=2$且最长匹配的长度$l^j=4$。由此可知，子串$S_{j+1,j+p}$是可以由$S_{1,j}$生成的，因而称之为$S_{1,j}$的再生扩展（Reproducible Extension）。LZ77算法的核心思想便来源于此——用历史中出现过的字符串做字典，编码未来出现的字符，以达到数据压缩的目的。在具体实现中，用滑动窗口（Sliding Window）字典存储历史字符，Lookahead-Buffer存储待压缩的字符，Cursor作为两者之间的分隔，如图所示 并且字典与Lookahead Buffer的长度是固定的。 ","date":"2023-06-27","objectID":"/lz77/:2:1","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#滑动窗口"},{"categories":["Lab"],"content":"\r压缩用$(p,l,c)$表示Lookahead Buffer中字符串的最长匹配结果，其中 $p$表示最长匹配时，字典中字符开始时的位置（相对于Cursor位置） $l$为最长匹配字符串的长度 $c$指Lookahead Buffer最长匹配结束时的下一字符 压缩的过程，就是重复输出$(p,l,c)$，并将Cursor移动至$l+1$，算法如下 Repeat: Output (p,l,c), Cursor --\u003e l+1 Until to end of string 压缩示例如图所示 ","date":"2023-06-27","objectID":"/lz77/:2:2","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#压缩"},{"categories":["Lab"],"content":"\r解压缩为了能保证正确解码，解压缩时的滑动窗口与压缩时要相同。在解压缩时，遇到$(p,l,c)$大致分为三类情况： $p==0$且$l==0$，即初始情况，这时直接解码$c$ $p\\geq l$，解码为字典dict[p:p+l+1] $p\u003cl$，即出现循环编码，则需要从左至右循环拼接，伪代码如下 for (i = p, k = 0; k \u003c length; i++, k++) out[cursor+k] = dict[i%cursor] 比如，dict=abcd，编码为(2,9,e)，则解压缩为output=abcdcdcdcdcdce。 ","date":"2023-06-27","objectID":"/lz77/:2:3","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#解压缩"},{"categories":["Lab"],"content":"\r实现用matlab实现一个简单的LZ77压缩算法，由于我的目的主要时压缩数组，因此用数组代替字符串进行压缩设计和测试，具体实现如下 classdef LZ77 % A simple implementation of LZ77 compression algorithm properties (SetAccess = private) window_size % dictionary buffer_size % lookahead buffer end methods function self = LZ77(d, h) if nargin == 2 self.window_size = d; self.buffer_size = h; elseif nargin == 1 self.window_size = d; self.buffer_size = 4; elseif nargin == 0 self.window_size = 6; self.buffer_size = 4; end end function [p, l, c] = longest_match(self, data, cursor) % Find the longest match between dictionary and % lookahead-buffer. % % arguments: (input) % data - data used to find longest match % cursor - position of data that seperate dictionary and % lookahead-buffer, from 0 to data length, value of % cursor should be equal to its left item's index % arguments: (output) % p - start point of longest match based on cursor % l - length of longest match % c - next character of longest match end_buffer = min(cursor + self.buffer_size, length(data)-1); p = -1; l = -1; c = ''; for i = cursor+1:end_buffer start_index = max(1, cursor - self.window_size + 1); sub_string = data(cursor+1:i); subs_len = length(sub_string); for j = start_index:cursor repetition = floor(subs_len / (cursor - j + 1)); last = rem(subs_len, (cursor - j + 1)); matched_string = [repmat(data(j:cursor), ... [1 repetition]), data(j:j+last-1)]; % if match, update p, l, c if isequal(matched_string, sub_string) \u0026\u0026 subs_len \u003e l p = cursor - j + 1; l = subs_len; c = data(i+1); end end end % if not match, return next character of cursor if p == -1 \u0026\u0026 l == -1 p = 0; l = 0; c = data(cursor + 1); end end function cm = compress(self, message) % Compress message % % arguments: (input) % message - data ready to compress % arguments: (output) % cm - compressed message i = 0; while i \u003c length(message) [p, l, c] = self.longest_match(message, i); if exist('cm', 'var') cm = [cm;[p,l,c]]; else cm = [p,l,c]; end i = i + l + 1; end end function dm = decompress(self, cm) % Decompress the compressed message % % arguments: (input) % cm - compressed message % arguments: (output) % dm - decompressed message cursor = 0; [n, ~] = size(cm); dm = []; for i = 1:n p = cm(i,1); l = cm(i,2); c = cm(i,3); if p == 0 \u0026\u0026 l == 0 dm = [dm, c]; elseif p \u003e= l dm = [dm, dm(cursor - p + 1: cursor - p + l), c]; elseif p \u003c l repetition = floor(l / p); last = rem(l, p); dm = [dm, repmat(dm(cursor-p+1:cursor), ... [1 repetition]), dm(cursor-p+1:cursor-p+last), c]; end cursor = cursor + l + 1; end end end end 整体的编码解码逻辑清楚，解码过程中的循环匹配也较为简单。在寻找最大匹配子串中，前置子串采用了和循环匹配一样的生成方式，其实其他方式也是一样的，这里的生成方式不本质。 值得注意的是，在寻找最大匹配子串中时，Lookahead-Buffer是不能取到数据的最后一位的，即需要length(data)-1。这是因为如果Cursor后的数据全部匹配的话，这样匹配后的下一个字符索引会超出边界，而保证Lookahead-Buffer最多只到倒数第二个字符的话，能够保证就算在全部匹配之后还能够留有一个字符附在$(p,l,c)$中的$c$ 处，从而有效避免了数组越界的情况，同时压缩效率也没有下降。 end_buffer = min(cursor + self.buffer_size, length(data)-1); ","date":"2023-06-27","objectID":"/lz77/:3:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#实现"},{"categories":["Lab"],"content":"\r性能在Dictionary和Lookahead-Buffer长度较小的时候，LZ77的压缩速度很快，但是压缩率很低，对于重复数据出现少的情况，甚至可能出现压缩后的数据比压缩之前还要大的情况。对于Dictionary和Lookahead-Buffer长度较小的情况，压缩效果较好，但是压缩速度很慢，且长度越大，压缩效果越好，压缩速度越慢。 对于Dictionary和Lookahead-Buffer长度均为80时，测试小天线的蓝盒子采集数据，压缩比约为1.29:1，压缩率为22%；扩大窗长度到200时，同样数据，压缩比约为1.49:1，压缩率为33%。 对于解压缩，由于和Dictionary和Lookahead-Buffer长度无关，因此解压缩速度均很快。 直接使用zip对2.29G的原始采集数据进行压缩，压缩比在3.35:1左右，由于也是基于LZ77算法的变种，性能相较直接的压缩有提升，但是整体数据量大也会导致压缩率的提升。 ","date":"2023-06-27","objectID":"/lz77/:4:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#性能"},{"categories":["Lab"],"content":"\r参考 Ziv, Jacob, and Abraham Lempel. “A universal algorithm for sequential data compression.” IEEE Transactions on information theory 23.3 (1977): 337-343. LZ77算法原理及实现 ","date":"2023-06-27","objectID":"/lz77/:5:0","series":["数据压缩"],"tags":["Research","Compression","Lossless"],"title":"LZ77📑","uri":"/lz77/#参考"},{"categories":["Life"],"content":"alist yyds","date":"2023-06-26","objectID":"/alist/","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/"},{"categories":["Life"],"content":"\rAlist是一个使用 Gin 和 Solidjs 开发的支持多种存储的文件列表程序，其具有优秀的性能和美观的用户界面，能够很好地对各种网盘以及本地存储文件进行管理和多平台访问（主要是视频、图像和音频）。 ","date":"2023-06-26","objectID":"/alist/:0:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#"},{"categories":["Life"],"content":"\r安装由于本机用 Windows 系统作为服务主机，直接利用 scoop 进行安装，参考其官网中的介绍，在 PowerShell 中输入如下命令： scoop bucket add main scoop install main/alist 待安装完成后输入 alist version 来查看是否正确安装。 ","date":"2023-06-26","objectID":"/alist/:1:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#安装"},{"categories":["Life"],"content":"\r配置Alist 具体配置在其官网有着极其详细的描述，在此只进行简单的配置和操作介绍，以下的步骤都是在安装了 Alist 的服务器主机中进行。 ","date":"2023-06-26","objectID":"/alist/:2:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#配置"},{"categories":["Life"],"content":"\r用户名和密码刚完成 Alist 安装后，在终端输入 alist server 将开启 alist 服务，默认的服务是在本机的 5244 端口，初始用户名为 admin ，同时在终端输出中会提示用户的初始密码，利用此用户名和密码可以在浏览器的 localhost:5244 中登录 alist ，如果成功登录，则说明 alist 初始化成功。 之后在下方点击管理可以进入到 Alist 的配置，在其中的个人资料中修改用户名和登录密码，点击保存，就完成了用户名和密码的设置。 ","date":"2023-06-26","objectID":"/alist/:2:1","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#用户名和密码"},{"categories":["Life"],"content":"\r云盘和存储添加各种存储的具体方式见 Alist 官网，其就是在 Alist 管理中选取存储，然后添加存储类型，之后按照官网中的描述进行配置，完成后就会在主页出现相应添加的存储部分。 ","date":"2023-06-26","objectID":"/alist/:2:2","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#云盘和存储"},{"categories":["Life"],"content":"\r开机自启","date":"2023-06-26","objectID":"/alist/:2:3","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#开机自启"},{"categories":["Life"],"content":"\r使用","date":"2023-06-26","objectID":"/alist/:3:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#使用"},{"categories":["Life"],"content":"\r浏览器","date":"2023-06-26","objectID":"/alist/:3:1","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#浏览器"},{"categories":["Life"],"content":"\rWebDav","date":"2023-06-26","objectID":"/alist/:3:2","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#webdav"},{"categories":["Life"],"content":"\r参考资料 Alist 官网 Alist · Github ","date":"2023-06-26","objectID":"/alist/:4:0","series":null,"tags":["Campus","Computer","Go"],"title":"Alist💾","uri":"/alist/#参考资料"},{"categories":["Life"],"content":"装电脑喽","date":"2023-06-25","objectID":"/computer/","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/"},{"categories":["Life"],"content":"我进入大学买的第一台笔记本是 HP 的 EliteBook，配置是 ","date":"2023-06-25","objectID":"/computer/:0:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#"},{"categories":["Life"],"content":"\r配置考虑到组装电脑的用途以及性价比，选取的装机配置如下表所示。 类型 价格 型号 尺寸 其他 CPU 2769 i7-13790F x GPU 2799 ASUS TUF RTX3060 30cm x 主板 1499 ROG STRIX B760-G MATX x 内存 939 16x2 DDR5 金士顿 x SSD 599 三星 980Pro 1T x 电源 599 海韵 G12 650W x 机箱 539 迎广 A3 显卡\u003c34cm x 散热 190 利民 PA120 x 总计 9933 ","date":"2023-06-25","objectID":"/computer/:1:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#配置"},{"categories":["Life"],"content":"\r装机\r","date":"2023-06-25","objectID":"/computer/:2:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#装机"},{"categories":["Life"],"content":"\r总结","date":"2023-06-25","objectID":"/computer/:3:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#总结"},{"categories":["Life"],"content":"\r致谢感谢胡昌宇同学在我装机时对我的帮助，特请奶茶一杯😊。 ","date":"2023-06-25","objectID":"/computer/:4:0","series":null,"tags":["Campus","Computer"],"title":"装机体验🖥️","uri":"/computer/#致谢"},{"categories":["Life"],"content":"毕业很累很热但是也很快乐！🎈","date":"2023-06-24","objectID":"/graduate/","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/"},{"categories":["Life"],"content":" 毕业很累很热但是也很快乐！🎈 ","date":"2023-06-24","objectID":"/graduate/:0:0","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/#"},{"categories":["Life"],"content":"\r照片\r","date":"2023-06-24","objectID":"/graduate/:1:0","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/#照片"},{"categories":["Life"],"content":"\r视频\r","date":"2023-06-24","objectID":"/graduate/:2:0","series":null,"tags":["Campus"],"title":"毕业快乐🎉","uri":"/graduate/#视频"}]